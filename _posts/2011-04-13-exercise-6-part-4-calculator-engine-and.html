---
title: Exercise 6 (part 4) – The Calculator Engine and Anonymous Methods
date: '2011-04-13T02:01:00.001+10:00'
tags:
- C# Specifics
- C# Exercise
- ".NET Specifics"
modified_time: '2011-04-13T02:01:28.397+10:00'
---

<p>In this post I’ll complete the RPN Calculator engine we’ve been looking at.&nbsp; This will complete the DLL I’ve been working on, and next time I’ll run through the code for a Console-based front-end.</p> <a name='more'></a> <p>Let’s get straight into the code.</p> <div class="csharpcode"><pre><span class="lnum">   1:  </span><span class="kwrd">using</span> System;</pre><pre><span class="lnum">   2:  </span><span class="kwrd">using</span> System.Collections.Generic;</pre><pre><span class="lnum">   3:  </span><span class="kwrd">using</span> System.Linq;</pre><pre><span class="lnum">   4:  </span>&nbsp;</pre><pre><span class="lnum">   5:  </span><span class="kwrd">namespace</span> LearningCSharp</pre><pre><span class="lnum">   6:  </span>{</pre><pre><span class="lnum">   7:  </span>    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> RPNCalculatorEngine</pre><pre><span class="lnum">   8:  </span>    {</pre><pre><span class="lnum">   9:  </span>        <span class="kwrd">private</span> Stack&lt;<span class="kwrd">double</span>&gt; _calculationStack;</pre><pre><span class="lnum">  10:  </span>        <span class="kwrd">private</span> InputLine _input;</pre><pre><span class="lnum">  11:  </span>        <span class="kwrd">private</span> List&lt;Operation&gt; _operations;</pre><pre><span class="lnum">  12:  </span>        <span class="kwrd">static</span> <span class="kwrd">private</span> <span class="kwrd">int</span> _baseOperationCount = 30;</pre><pre><span class="lnum">  13:  </span>&nbsp;</pre></div>
<p>The <code>RPNCalculatorEngine</code> class defines four <strong>private fields</strong>: one for the operand stack, one for the input line, one for the list of operations supported by the engine, and one for the number of operations supported by the engine.&nbsp; The <code>_calculationStack</code> and <code>_operations</code> fields are declared as generic types from the <code>System.Collections.Generic</code> <strong>namespace</strong>.&nbsp; Note that the <code>_operations</code> field is a <code>List</code> of <code>Operation</code>.&nbsp; We’re actually going to use it to store objects of <code>Operation</code>, <code>BinaryOperation</code>, <code>UnaryOperation</code> and <code>ConstantOperation</code> types, but that’s okay because the last three are derived from Operation as we saw in the last post.</p>
<p>Next, let’s have a look at the constructor:</p>
<div class="csharpcode"><pre><span class="lnum">  14:  </span>        <span class="kwrd">public</span> RPNCalculatorEngine()</pre><pre><span class="lnum">  15:  </span>        {</pre><pre><span class="lnum">  16:  </span>            _calculationStack = <span class="kwrd">new</span> Stack&lt;<span class="kwrd">double</span>&gt;();</pre><pre><span class="lnum">  17:  </span>            _input = <span class="kwrd">new</span> InputLine();</pre><pre><span class="lnum">  18:  </span>            _input.Clear();</pre><pre><span class="lnum">  19:  </span>            _operations = <span class="kwrd">new</span> List&lt;Operation&gt;(_baseOperationCount);</pre><pre><span class="lnum">  20:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Zero"</span>, <span class="str">"0"</span>, <span class="str">"0"</span>, <span class="str">'0'</span>));</pre><pre><span class="lnum">  21:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"One"</span>, <span class="str">"1"</span>, <span class="str">"1"</span>, <span class="str">'1'</span>));</pre><pre><span class="lnum">  22:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Two"</span>, <span class="str">"2"</span>, <span class="str">"2"</span>, <span class="str">'2'</span>));</pre><pre><span class="lnum">  23:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Three"</span>, <span class="str">"3"</span>, <span class="str">"3"</span>, <span class="str">'3'</span>));</pre><pre><span class="lnum">  24:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Four"</span>, <span class="str">"4"</span>, <span class="str">"4"</span>, <span class="str">'4'</span>));</pre><pre><span class="lnum">  25:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Five"</span>, <span class="str">"5"</span>, <span class="str">"5"</span>, <span class="str">'5'</span>));</pre><pre><span class="lnum">  26:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Six"</span>, <span class="str">"6"</span>, <span class="str">"6"</span>, <span class="str">'6'</span>));</pre><pre><span class="lnum">  27:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Seven"</span>, <span class="str">"7"</span>, <span class="str">"7"</span>, <span class="str">'7'</span>));</pre><pre><span class="lnum">  28:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Eight"</span>, <span class="str">"8"</span>, <span class="str">"8"</span>, <span class="str">'8'</span>));</pre><pre><span class="lnum">  29:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Nine"</span>, <span class="str">"9"</span>, <span class="str">"9"</span>, <span class="str">'9'</span>));</pre><pre><span class="lnum">  30:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Decimal"</span>, <span class="str">"."</span>, <span class="str">"."</span>, <span class="str">'.'</span>));</pre><pre><span class="lnum">  31:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Exponent"</span>, <span class="str">"Exp"</span>, <span class="str">"E"</span>, <span class="str">'E'</span>));</pre><pre><span class="lnum">  32:  </span>            _operations.Add(<span class="kwrd">new</span> Operation(<span class="str">"Back"</span>, <span class="str">"Bck"</span>, <span class="str">"Back"</span>, <span class="str">'\b'</span>));</pre><pre><span class="lnum">  33:  </span>            _operations.Add(<span class="kwrd">new</span> UnaryOperation(<span class="str">"Enter"</span>, <span class="str">"Cpy"</span>, <span class="str">"Enter"</span>, <span class="str">'\r'</span>, Copy));</pre><pre><span class="lnum">  34:  </span>            _operations.Add(<span class="kwrd">new</span> UnaryOperation(<span class="str">"Negate"</span>, <span class="str">"Neg"</span>, <span class="str">"+/-"</span>, <span class="str">'_'</span>, x =&gt; -x));</pre><pre><span class="lnum">  35:  </span>            _operations.Add(<span class="kwrd">new</span> UnaryOperation(<span class="str">"Inverse"</span>, <span class="str">"Inv"</span>, <span class="str">"1/x"</span>, <span class="str">'\\'</span>, x =&gt; 1 / x));</pre><pre><span class="lnum">  36:  </span>            _operations.Add(<span class="kwrd">new</span> ConstantOperation(<span class="str">"PI"</span>, <span class="str">"PI"</span>, <span class="str">"\x03c0"</span>, <span class="str">'p'</span>, Math.PI));</pre><pre><span class="lnum">  37:  </span>            _operations.Add(<span class="kwrd">new</span> ConstantOperation(<span class="str">"e"</span>, <span class="str">"e"</span>, <span class="str">"e"</span>, <span class="str">'e'</span>, Math.E));</pre><pre><span class="lnum">  38:  </span>            _operations.Add(<span class="kwrd">new</span> BinaryOperation(<span class="str">"Add"</span>, <span class="str">"Add"</span>, <span class="str">"+"</span>, <span class="str">'+'</span>, (y, x) =&gt; x + y));</pre><pre><span class="lnum">  39:  </span>            _operations.Add(<span class="kwrd">new</span> BinaryOperation(<span class="str">"Subtract"</span>, <span class="str">"Sub"</span>, <span class="str">"-"</span>, <span class="str">'-'</span>, (y, x) =&gt; x - y));</pre><pre><span class="lnum">  40:  </span>            _operations.Add(<span class="kwrd">new</span> BinaryOperation(<span class="str">"Multiply"</span>, <span class="str">"Mul"</span>, <span class="str">"x"</span>, <span class="str">'*'</span>, (y, x) =&gt; x * y));</pre><pre><span class="lnum">  41:  </span>            _operations.Add(<span class="kwrd">new</span> BinaryOperation(<span class="str">"Divide"</span>, <span class="str">"Div"</span>, <span class="str">"\xf7"</span>, <span class="str">'/'</span>, (y, x) =&gt; x / y));</pre><pre><span class="lnum">  42:  </span>            _operations.Add(<span class="kwrd">new</span> BinaryOperation(<span class="str">"Modulus"</span>, <span class="str">"Mod"</span>, <span class="str">"mod"</span>, <span class="str">'%'</span>, (y, x) =&gt; x % y));</pre><pre><span class="lnum">  43:  </span>            _operations.Add(<span class="kwrd">new</span> UnaryOperation(<span class="str">"Factorial"</span>, <span class="str">"Fac"</span>, <span class="str">"!"</span>, <span class="str">'!'</span>, Factorial));</pre><pre><span class="lnum">  44:  </span>            _operations.Add(<span class="kwrd">new</span> UnaryOperation(<span class="str">"Cosine"</span>, <span class="str">"Cos"</span>, <span class="str">"cos"</span>, <span class="str">'c'</span>, Math.Cos));</pre><pre><span class="lnum">  45:  </span>            _operations.Add(<span class="kwrd">new</span> UnaryOperation(<span class="str">"Sine"</span>, <span class="str">"Sin"</span>, <span class="str">"sin"</span>, <span class="str">'s'</span>, Math.Sin));</pre><pre><span class="lnum">  46:  </span>            _operations.Add(<span class="kwrd">new</span> UnaryOperation(<span class="str">"Tangent"</span>, <span class="str">"Tan"</span>, <span class="str">"tan"</span>, <span class="str">'t'</span>, Math.Tan));</pre><pre><span class="lnum">  47:  </span>            _operations.Add(<span class="kwrd">new</span> UnaryOperation(<span class="str">"Square"</span>, <span class="str">"x\xb2"</span>, <span class="str">"x\xb2"</span>, <span class="str">'S'</span>, x =&gt; Math.Pow(x, 2)));</pre><pre><span class="lnum">  48:  </span>            _operations.Add(<span class="kwrd">new</span> UnaryOperation(<span class="str">"Cube"</span>, <span class="str">"x\xb3"</span>, <span class="str">"x\xb3"</span>, <span class="str">'C'</span>, x =&gt; Math.Pow(x, 3)));</pre><pre><span class="lnum">  49:  </span>            _operations.Add(<span class="kwrd">new</span> UnaryOperation(<span class="str">"SquareRoot"</span>, <span class="str">"RtX"</span>, <span class="str">"\x221a"</span>, <span class="str">'R'</span>, Math.Sqrt));</pre><pre><span class="lnum">  50:  </span>        }</pre><pre><span class="lnum">  51:  </span>&nbsp;</pre></div>
<p>So that all looks a little over the top, and looking back on it now I can think of a number of better ways of doing this, but basically all we’re doing is initialising the operand stack and the input line, and populating the list of built-in operations.&nbsp; I say “built-in”, because, although I haven’t written a method to enable it, with this design it’s possible for the calculator front-end that uses this DLL to extend the list of operations the calculator can perform.</p>
<p>There are two interesting points here.&nbsp; One is the mixing of operation types in the one list that I mentioned before.&nbsp; It’s just classic OO polymorphism, but it’s interesting to see it in action.</p>
<p>The more important thing to notice, from the point of view of learning C#, are the way that the functions are passed to the operation constructors.&nbsp; Take the <strong>Add</strong> operation, for example.&nbsp; The function passed to the constructor is <code>(x, y) =&gt; x + y</code>.&nbsp; At first that looks more than a little strange, but it’s called a <strong>lambda expression</strong>, and it’s basically just a notation for defining anonymous, or inline, functions.&nbsp; Basically it defines a function that takes two operands and returns their sum.&nbsp; In this context at least, we don’t need to declare the types of the operands, because the compiler can infer them from the context in which we’re using the <strong>lambda</strong>.&nbsp; The lambda expression is mapped to the <strong>delegate</strong> type we used to declare the constructor parameter (<code>BinaryO p</code>), and so the operands are taken to be two doubles, and the result their sum.</p>
<p>We also see a different application of the <strong>delegate</strong> parameter here.&nbsp; The trig operations (sin, cos and tan) are not defined in terms of <strong>lambda</strong>s.&nbsp; We don’t need an anonymous function because we already have perfectly suitable methods defined in the <code>Math</code> class.&nbsp; Instead of a <strong>lambda</strong> we just pass in a reference to the appropriate method. As long as the signature of the method matches the signature of the <strong>delegate</strong> type, we’re fine.</p>
<p>One other point of interest is the use of Unicode character codes in some of the strings.&nbsp; In C#, all <code>string</code>s and <code>char</code>s, are defined in terms of Unicode characters.&nbsp; Any Unicode character can be used in a <code>char</code> or <code>string</code> literal by meas of the <code>\x…</code> escape code.</p>
<div class="csharpcode"><pre><span class="lnum">  52:  </span>        public string InputString</pre><pre><span class="lnum">  53:  </span>        {</pre><pre><span class="lnum">  54:  </span>            get</pre><pre><span class="lnum">  55:  </span>            {</pre><pre><span class="lnum">  56:  </span>                return this._input.ToString();</pre><pre><span class="lnum">  57:  </span>            }</pre><pre><span class="lnum">  58:  </span>        }</pre><pre><span class="lnum">  59:  </span>&nbsp;</pre></div>
<p>Here we have a read-only property to get a string representation of the current input line.&nbsp; Note that the property has a getter, but not setter.</p>
<div class="csharpcode"><pre><span class="lnum">  60:  </span>        public void PressKey(int keyIndex)</pre><pre><span class="lnum">  61:  </span>        {</pre><pre><span class="lnum">  62:  </span>            if (keyIndex &lt; _operations.Count)</pre><pre><span class="lnum">  63:  </span>            {</pre><pre><span class="lnum">  64:  </span>                Operation operation = _operations[keyIndex];</pre><pre><span class="lnum">  65:  </span>                if (_input.AddChar(operation.ShortCut)) return;</pre><pre><span class="lnum">  66:  </span>                if (operation.ShortCut == '</span>\b' &amp;&amp; _calculationStack.Count &gt; 0)</pre><pre><span class="lnum">  67:  </span>                {</pre><pre><span class="lnum">  68:  </span>                    _calculationStack.Pop();</pre><pre><span class="lnum">  69:  </span>                    <span class="kwrd">return</span>;</pre><pre><span class="lnum">  70:  </span>                }</pre><pre><span class="lnum">  71:  </span>                <span class="kwrd">if</span> (operation.HasFunction)</pre><pre><span class="lnum">  72:  </span>                {</pre><pre><span class="lnum">  73:  </span>                    <span class="kwrd">if</span> (_input.IsActive)</pre><pre><span class="lnum">  74:  </span>                    {</pre><pre><span class="lnum">  75:  </span>                        _calculationStack.Push(_input.ToDouble());</pre><pre><span class="lnum">  76:  </span>                        _input.Clear();</pre><pre><span class="lnum">  77:  </span>                        <span class="kwrd">if</span> (operation.Name == <span class="str">"Enter"</span>) <span class="kwrd">return</span>;</pre><pre><span class="lnum">  78:  </span>                    }</pre><pre><span class="lnum">  79:  </span>                    operation.Execute(_calculationStack);</pre><pre><span class="lnum">  80:  </span>                }</pre><pre><span class="lnum">  81:  </span>            }</pre><pre><span class="lnum">  82:  </span>        }</pre><pre><span class="lnum">  83:  </span>        </pre></div>
<p>The <code>PressKey</code> method is basically the core of the engine.&nbsp; It is the main method called by the calculator UI to pass user key strokes to the engine.&nbsp; The interface is defined in terms of a number of keys, each of which map to one of the operations in the calculator engine.&nbsp; The parameter passed to this method is the numeric index of the key that was pressed (operation to be&nbsp; executed).</p>
<p>The <code>keyIndex</code> is check to see if it’s in the correct range, and then operation associated with the key is retrieved.&nbsp; The character associated with the operation is passed to the <code>inputLine</code>, and if it was a valid input character (<code>_input.AddChar()</code> returns true) we finish processing the keystroke.&nbsp; If the key pressed was the back-space key then we just pop the top operand from the stack and return.</p>
<p>Otherwise we check if the operation has a function defined.&nbsp; If so, we check if the <code>inputLine</code> is active and push it to the stack if it is.&nbsp; We then execute the operation.&nbsp; That’s all there is to it.&nbsp; As we saw last post, the operation pops its operands from the stack and returns its result to the stack.</p>
<div class="csharpcode"><pre><span class="lnum">  84:  </span>        <span class="kwrd">public</span> <span class="kwrd">double</span>? <span class="kwrd">this</span>[<span class="kwrd">int</span> index]</pre><pre><span class="lnum">  85:  </span>        {</pre><pre><span class="lnum">  86:  </span>            get</pre><pre><span class="lnum">  87:  </span>            {</pre><pre><span class="lnum">  88:  </span>                <span class="kwrd">if</span> (index &lt; _calculationStack.Count)</pre><pre><span class="lnum">  89:  </span>                    <span class="kwrd">return</span> _calculationStack.ElementAt&lt;<span class="kwrd">double</span>&gt;(index);</pre><pre><span class="lnum">  90:  </span>                <span class="kwrd">else</span></pre><pre><span class="lnum">  91:  </span>                    <span class="kwrd">return</span> <span class="kwrd">null</span>;</pre><pre><span class="lnum">  92:  </span>            }</pre><pre><span class="lnum">  93:  </span>        }</pre><pre><span class="lnum">  94:  </span>&nbsp;</pre></div>
<p>Here are a couple of new things we haven’t seen before.&nbsp; The above code is an <strong>indexer</strong>.&nbsp; We’ll see how the indexer is called next post when we look at the calculator UI.&nbsp; For now it’s sufficient to say that it behaves a little like a property, but with an index parameter.&nbsp; This indexer only has a getter, so it’s read only, and it returns the value of the appropriate position on the operand stack, or null if the index is out of range.</p>
<p>In order to be able to return null, the return type is declared as<code>double?</code>.&nbsp; This is the same as Nullable&lt;double&gt;, and all value types in C# have a similar nullable variant.&nbsp; A nullable type has two important properties – <code>HasValue</code> and <code>Value</code>.&nbsp; The former returns <strong>true</strong> if a value is assigned, or false if the variable is null.&nbsp; The latter returns the vaue that has been assigned.</p>
<div class="csharpcode"><pre><span class="lnum">  95:  </span>        <span class="kwrd">public</span> Operation GetOperation(<span class="kwrd">int</span> index)</pre><pre><span class="lnum">  96:  </span>        {</pre><pre><span class="lnum">  97:  </span>            <span class="kwrd">return</span> index &lt; _operations.Count ? _operations[index] : <span class="kwrd">null</span>;</pre><pre><span class="lnum">  98:  </span>        }</pre><pre><span class="lnum">  99:  </span>&nbsp;</pre></div>
<p><code>GetOperation</code> just returns a reference to the operation with the specified index in the operations list.&nbsp; It probably would have made sense to implement this as an indexer, where the index parameter was the character code associated with the operation.&nbsp; I can’t remember now why I didn’t end up doing it that way.</p>
<div class="csharpcode"><pre><span class="lnum"> 100:  </span>        <span class="kwrd">private</span> <span class="kwrd">double</span> Copy(<span class="kwrd">double</span> operand)</pre><pre><span class="lnum"> 101:  </span>        {</pre><pre><span class="lnum"> 102:  </span>            _calculationStack.Push(operand);</pre><pre><span class="lnum"> 103:  </span>            <span class="kwrd">return</span> operand;</pre><pre><span class="lnum"> 104:  </span>        }</pre><pre><span class="lnum"> 105:  </span>&nbsp;</pre></div>
<p>The last two members of this class are a couple of methods to implement operation functions that we can’t handle just with a <strong>lambda</strong>.&nbsp;&nbsp; <code>Copy</code> pushes a copy of it’s parameter onto the stack, and then returns then same value.&nbsp; Recall that the <code>Operation</code> class pushes this return value onto the stack.&nbsp; The effect of this is that the top entry on the stack is copied.</p>
<div class="csharpcode"><pre><span class="lnum"> 106:  </span>        <span class="kwrd">private</span> <span class="kwrd">double</span> Factorial(<span class="kwrd">double</span> operand)</pre><pre><span class="lnum"> 107:  </span>        {</pre><pre><span class="lnum"> 108:  </span>            <span class="kwrd">if</span> (operand &gt;= 0d &amp;&amp; Math.Floor(operand) == operand)    <span class="rem">// Check that operand is a positive integer</span></pre><pre><span class="lnum"> 109:  </span>            {</pre><pre><span class="lnum"> 110:  </span>                <span class="kwrd">double</span> result = 1;</pre><pre><span class="lnum"> 111:  </span>                <span class="kwrd">while</span> (operand &gt; 1)</pre><pre><span class="lnum"> 112:  </span>                {</pre><pre><span class="lnum"> 113:  </span>                    result *= operand--;</pre><pre><span class="lnum"> 114:  </span>                    <span class="kwrd">if</span> (<span class="kwrd">double</span>.IsInfinity(result))</pre><pre><span class="lnum"> 115:  </span>                    {</pre><pre><span class="lnum"> 116:  </span>                        <span class="kwrd">throw</span> <span class="kwrd">new</span> OverflowException(<span class="str">"Fac: Result too large"</span>);</pre><pre><span class="lnum"> 117:  </span>                    }</pre><pre><span class="lnum"> 118:  </span>                }</pre><pre><span class="lnum"> 119:  </span>                <span class="kwrd">return</span> result;</pre><pre><span class="lnum"> 120:  </span>            }</pre><pre><span class="lnum"> 121:  </span>            <span class="kwrd">else</span></pre><pre><span class="lnum"> 122:  </span>            {</pre><pre><span class="lnum"> 123:  </span>                _calculationStack.Push(operand);    <span class="rem">// Return the operand to the stack</span></pre><pre><span class="lnum"> 124:  </span>                <span class="kwrd">throw</span> <span class="kwrd">new</span> ArgumentOutOfRangeException(<span class="str">"Fac: Must be positive integer"</span>);</pre><pre><span class="lnum"> 125:  </span>            }</pre><pre><span class="lnum"> 126:  </span>        }</pre><pre><span class="lnum"> 127:  </span>    }</pre><pre><span class="lnum"> 128:  </span>}</pre></div>
<p>This last method implements a basic factorial calculation.&nbsp; If the operand is negative, the factorial operation is undefined, so we just push the operand back onto the stack and throw and <strong>exception</strong>.</p>
<p>We’ve seen in a number of places in this post, the use of members of the <code>Math</code> class.&nbsp;&nbsp; This is a class of static methods implementing a fairly wide range of standard mathematical operations.</p>
<p>So that ties up the RPN Calculator Engine DLL.&nbsp; Next time we’ll have a look at a simple console-based user interface for the calculator, and look at some pretty cool capabilities of the <code>Console</code> class.&nbsp; </p>
<p>See you then.</p>  