---
layout: post
title: Fun with Deconstructors
date: '2018-06-22T14:17:00.000+10:00'
tags:
- Deconstructors
- C#
modified_time: '2018-08-24T21:11:59.081+10:00'
---

In my <a href="http://adventures-in-code.blogspot.com/2018/06/fun-with-initialisers.html">last post</a> I had some fun with C# initialisers.  This time we'll look at Deconstructors that were introduced as part of the new <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7#tuples">ValueTuple support in C# 7.0</a>. The code we'll look at this time will probably be slightly more useful for real-world propduction code.<br /><h3>The basics</h3>I won't go into a great deal of detail on the basics here because it's already well covered in the above Microsoft docs link, and in another <a href="https://andrewlock.net/deconstructors-for-non-tuple-types-in-c-7-0/">blog post</a> about support for deconstructors in custom types.  Suffice to say that ValueTuple types, and custom types with an appropriate <code>Deconstruct()</code> method can be deconstructed, or broken apart, to multiple variables in a single assignment statement. So you can do stuff like:<br /><pre><code>var point = (1.2, 5.3);<br />var (x, y) = point;<br /><br />var customer = GetCustomer();<br />var (firstName, lastName) = customer;<br /></code></pre><h3>Beyond the basics</h3>Deconstructors are also supported for types you can't change by means of extension methods.  So, we could deconstruct a <code>DateTime</code>, for example.  <br /><pre><code>public static void Deconstruct(this DateTime value, out int year, out int month, out int day)<br />{<br />    year = value.Year;<br />    month = value.Month;<br />    day = value.Day;<br />}<br /><br />var (year, month, day) = DateTime.Today;<br />Console.WriteLine($"Today is {year}/{month}/{day}");<br /></code></pre>That's cool, but you've probably read about that usage in a number of places. What I really want to look at, though, is what happens when you apply deconstruction to arrays.<br /><h3>Deconstructing arrays</h3>You've probably seen, or written, code like this:<br /><pre><code>string[] nameComponents = customer.Name.Split(' ');<br />string firstName = nameComponents[0];<br />string lastName = nameComponents[1];<br /><br />// Do something with firstName and lastName<br /></code></pre><br />In this code I deliberately left the types explicit, rather than using <code>var</code>, to make them clear.<br />If we define an appropriate extension method we can greatly simplify this code by removing a bunch of details that just get in the way of readibility.<br /> <pre><code>public static void Deconstruct(this string[] array, out string value1, out string value2)<br />{<br />    value1 = array[0];<br />    value2 = array[1];<br />}<br /><br />var (firstName, lastName) = customer.Name.Split(' ');<br />//Do something with firstName and lastName<br /></code></pre>Notice that the <code>Deconstruct</code> method only cares about the type of the array and the return (<code>out</code>) parameters. You can create multiple methods with different numbers of <code>out</code> parameters for arrays of different sizes. The method to use is chosen by the number of variables on the left side on your deconstruction assignment statement. Obviously you need to be careful that the array you're deconstructing actually has sufficient elements<br />You can see that this technique has immediate application to string parsing, but it could probably be useful for other scenarios as well, and also for arrays of other types. You don't need to define separate methods for different array types, however. This technique can also be used with generics:<br /><pre><code>public static void Deconstruct&lt;T&gt;(this T[] array, out T value1, out T value2)<br />{<br />    value1 = array[0];<br />    value2 = array[1];<br />}<br /></code></pre>Using this method you can now pull the first two elements out of an array of any type.<br />Pretty cool, huh? But we don't have to stop at arrays. Another area where assignments and ceremony get in the way is in iterating over dictionaries.<br /><h3>Deconstructing dictionaries</h3>Okay, so we're not actually going to apply deconstruction to the dictionary itself, but deconstruction can be useful to improve readability when iterating over dictionaries. Before we get to that, though, let's look at how we typically enumerate a dictionary.<br /><br />Let's say we're using a dictionary to keep a count of the occurrences of words in a block of text. We then want to report those results. <br /><pre><code>Dictionary&lt;string, int&gt; wordCounts = CountWords(text) ;<br /></code></pre>When we want to report these results we can enumerate the dictionary using a <code>foreach</code> loop.  <br /><pre><code>foreach (var wordCount in wordCounts) <br />{<br />    Console.WriteLine($"{wordCount.Key} : {wordCount.Value}");<br />}<br /></code></pre>This is fine. It works, and we can easily see what is doing. But the naming of things is not immediately clear, because it has more to do with the data structure we're using than the problem we're trying to solve. First, we have to have a name for each key-value pair in the dictionary. Secondly, the actual word and its count are accessed using the Key and Value properties, the names of which mean nothing in the business context. We could assign these values to all named local<br /><br />We can improve this slightly by enumerating the keys in the dictionary, rather than the key-value pairs.  <br /><pre><code>foreach (var word in wordCounts.Keys)<br />{<br />    Console.WriteLine($"{word} : {wordCounts[word]}");<br />} <br /></code></pre>This is better, but there's still some ceremony in there. What happens if we define a deconstructor for the key-value pair? I'm glad you asked.  <br /><pre><code>public static void Deconstruct&lt;TKey, TValue&gt;(this KeyValuePair&lt;TKey, TValue&gt; kvp, TKey key, TValue value) <br />{<br />    key = kvp.Key;<br />    value = kvp.Value;<br />} <br /><br />foreach (var (word, count) in wordCounts)<br />{<br />    Console.WriteLine($"{word} : {count}");<br />} <br /></code></pre>Look at that! A clear enumeration with well-named variables that clearly communicates the business concern with very little ceremony.<br /><br />"But," you may say, "look at the variable names in the Decontruct method. They're meaningless." To which I would reply, "no they're not." That's a generic helper method that operates on any KeyValuePair, with names that are perfectly meaningful in that context. And really&nbsp; what else are you going to call them?<br /><h3>But what about performance?</h3>I could quote Donald Knuth about the evils of premature optimization, but I won't. Suffice to say, there's nothing to worry about.&nbsp; I ran some tests timing 100 enumerations of a dictionary with 100k entries using each of the three techniques above. Each test run took 3-5 seconds to complete.<br /><br />Enumerating the dictionary itself, as in the first example above, is the fastest option.&nbsp; However, the third example, where we deconstruct the KeyValuePair, only has about a 1% performance hit.&nbsp; Given the improvement in readability, I'd say that's worth it.<br /><br />The worst option, performance wise, was the second example above where we enumerate the keys and then index into the dictionary in the loop. That had a 30-50% performance hit over enumerating the dictionary itself.<br /><h3>Conclusion</h3>The new Deconstructor support in C#7.0 not only aids in handling ValueTuples, but can also be used to pull apart others types such as arrays and dictionaries with less code and greater readability.