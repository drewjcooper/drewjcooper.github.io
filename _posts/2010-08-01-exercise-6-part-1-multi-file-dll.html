---
title: Exercise 6 (part 1) – Multi-file DLL project
date: '2010-08-01T21:36:00.001+10:00'
tags:
- C# Specifics
- C# Exercise
modified_time: '2010-08-01T21:46:36.891+10:00'
thumbnail: http://lh3.ggpht.com/_8osJtRBSdMg/TFVcQzPCqTI/AAAAAAAAARE/SYPnqzpZcRI/s72-c/image_thumb17.png?imgmax=800
---

<p>For his 6th exercise, <a href="http://www.jobsnake.com/seek/articles/index.cgi?openarticle&amp;8533" target="_blank">Prashant suggests</a> writing a&#160; </p>  <blockquote>   <p>Scientific calculator supporting addition, subtraction, multiplication, division, square-root, square, cube, sin, cos, tan, Factorial, inverse, modulus.</p> </blockquote>  <p>In planning my solution to this exercise, I thought it would be cool to write a DLL (a Class Library in .NET parlance) to be the core engine of the calculator, and then write a console-based front-end.&#160; Later, when I’m learning WPF I can write a graphical front-end to the same DLL.</p> <a name='more'></a>  <p>So with that in mind, I set about designing the calculator engine.&#160; I decided to create an RPN calculator inspired by my HP 48GX.&#160; I decided to write a class to handle the input line, a group of classes to handle the various operations the calculator can perform, and the engine class to tie it all together and provide the interface used by the front-end.&#160; The diagram below shows the class structure.</p>  <p><a href="http://lh6.ggpht.com/_8osJtRBSdMg/TFVcQSj77SI/AAAAAAAAARA/1Th1e6SAPMU/s1600-h/image19.png"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="RPN Calculator code layout" border="0" alt="RPN Calculator code layout" src="http://lh3.ggpht.com/_8osJtRBSdMg/TFVcQzPCqTI/AAAAAAAAARE/SYPnqzpZcRI/image_thumb17.png?imgmax=800" width="592" height="494" /></a></p>  <p>As the diagram shows I also decided to split the project over multiple code files.&#160; This is very easy to do in C# and, as shown, even classes can be defined in multiple files.</p>  <p>But first things first.&#160; How is writing a DLL different to writing a console application?&#160; At the code level, not much.&#160; The only difference in the code in the absence of a <code>Main()</code> method.&#160; The main difference is in the compiler.&#160; The <strong>csc.exe</strong> compiler has a command-line option call <strong>/target</strong>.&#160; By default this is set as /target:exe, which tells the compiler to produce a console executable.&#160; The <strong>/target:winexe</strong> option produces, you guessed it, a Windows executable, and <strong>/target:library</strong> tells the compiler to create a DLL.&#160; Of course, if you’re using Visual Studio, or Visual C# Express, you don’t need to worry about this – just specify Class Library as the project type when you’re creating a new project.</p>  <p>There’s a couple of interesting things to note about the C# code when writing a library over multiple code files, and in order to show you I need to show you the basic skeleton of the code.&#160; I’ll cover the details of the code in each file in the next few posts.&#160; Here’s the basic skeleton:</p>  <div class="csharpcode">   <pre class="filename">RPNCalculator.cs</pre>

  <pre><span class="lnum">   1:  </span><span class="kwrd">using</span> System;</pre>

  <pre><span class="lnum">   2:  </span><span class="kwrd">using</span> System.Collections.Generic;</pre>

  <pre><span class="lnum">   3:  </span><span class="kwrd">using</span> System.Linq;</pre>

  <pre><span class="lnum">   4:  </span>&#160;</pre>

  <pre><span class="lnum">   5:  </span><span class="kwrd">namespace</span> LearningCSharp</pre>

  <pre><span class="lnum">   6:  </span>{</pre>

  <pre><span class="lnum">   7:  </span>    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> RPNCalculatorEngine</pre>

  <pre><span class="lnum">   8:  </span>    {</pre>

  <pre><span class="lnum"> 129:  </span>    }</pre>

  <pre><span class="lnum"> 130:  </span>}</pre>
</div>

<p></p>

<div class="csharpcode">
  <pre class="filename">RPNCalculator.Operations.cs</pre>

  <pre><span class="lnum">   1:  </span><span class="kwrd">using</span> System;</pre>

  <pre><span class="lnum">   2:  </span><span class="kwrd">using</span> System.Collections.Generic;</pre>

  <pre><span class="lnum">   3:  </span>&#160;</pre>

  <pre><span class="lnum">   4:  </span><span class="kwrd">namespace</span> LearningCSharp</pre>

  <pre><span class="lnum">   5:  </span>{</pre>

  <pre><span class="lnum">   6:  </span>    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> RPNCalculatorEngine</pre>

  <pre><span class="lnum">   7:  </span>    {</pre>

  <pre><span class="lnum">   8:  </span>        <span class="kwrd">public</span> <span class="kwrd">delegate</span> <span class="kwrd">double</span> BinaryOp(<span class="kwrd">double</span> operand1, <span class="kwrd">double</span> operand2);</pre>

  <pre><span class="lnum">   9:  </span>        <span class="kwrd">public</span> <span class="kwrd">delegate</span> <span class="kwrd">double</span> UnaryOp(<span class="kwrd">double</span> operand);</pre>

  <pre><span class="lnum">  10:  </span>&#160;</pre>

  <pre><span class="lnum">  11:  </span>        <span class="kwrd">public</span> <span class="kwrd">class</span> Operation</pre>

  <pre><span class="lnum">  12:  </span>        {</pre>

  <pre><span class="lnum">  35:  </span>        }</pre>

  <pre><span class="lnum">  36:  </span>&#160;</pre>

  <pre><span class="lnum">  37:  </span>        <span class="kwrd">public</span> <span class="kwrd">class</span> BinaryOperation : Operation</pre>

  <pre><span class="lnum">  38:  </span>        {</pre>

  <pre><span class="lnum">  58:  </span>        }</pre>

  <pre><span class="lnum">  59:  </span>&#160;</pre>

  <pre><span class="lnum">  60:  </span>        <span class="kwrd">public</span> <span class="kwrd">class</span> UnaryOperation : Operation</pre>

  <pre><span class="lnum">  61:  </span>        {</pre>

  <pre><span class="lnum">  81:  </span>        }</pre>

  <pre><span class="lnum">  82:  </span>&#160;</pre>

  <pre><span class="lnum">  83:  </span>        <span class="kwrd">public</span> <span class="kwrd">class</span> ConstantOperation : Operation</pre>

  <pre><span class="lnum">  84:  </span>        {</pre>

  <pre><span class="lnum"> 100:  </span>        }</pre>

  <pre><span class="lnum"> 101:  </span>    }</pre>

  <pre><span class="lnum"> 102:  </span>}</pre>
</div>

<p></p>

<div class="csharpcode">
  <pre class="filename">RPNCalculator.InputLine.cs</pre>

  <pre><span class="lnum">   1:  </span><span class="kwrd">namespace</span> LearningCSharp</pre>

  <pre><span class="lnum">   2:  </span>{</pre>

  <pre><span class="lnum">   3:  </span>    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> RPNCalculatorEngine</pre>

  <pre><span class="lnum">   4:  </span>    {</pre>

  <pre><span class="lnum">   5:  </span>        <span class="kwrd">protected</span> <span class="kwrd">struct</span> InputLine</pre>

  <pre><span class="lnum">   6:  </span>        {</pre>

  <pre><span class="lnum"> 116:  </span>        }</pre>

  <pre><span class="lnum"> 117:  </span>    }</pre>

  <pre><span class="lnum"> 118:  </span>}</pre>
</div>

<p>One thing that will immediately jump out to the C/C++ programmer is the complete absence of header files.&#160; C# has no need of them.&#160; When compiling multiple files like this into a single <strong>assembly</strong> (as an executable file - .exe or .dll - is called in the .NET world), the compiler treats all the files together as one, large code-space.&#160; When referencing methods in external assemblies, the compiler is able to look into the assembly at compile-time and make use of the meta-data therein to hook it all together.</p>

<p>There’re a few other things to notice in the code above, but I’ll deal with just two for the moment.&#160; The rest I’ll deal with when I cover the individual files in detail.</p>

<p>The first is that the <code>RPNCalculatorEngine</code> class is defined in all three files.&#160; Notice, though, the use of the <code>partial</code> keyword in the class declaration.&#160;&#160; This keyword tells compiler that there may be code in other files that goes to fully defining this class.&#160; In every file in which the class is declared the <code>partial</code> keyword must be used, and access modifier (in this case <code>public</code>) must be the same.</p>

<p>The other thing to notice here is that most of the classes and other types are nested in the <code>RPNCalculatorEngine</code> class.&#160; I did this for two reasons – one, because these types don’t have much meaning outside the context of the <code>RPNCalculatorEngine</code> class; and two, to show that it can be done. </p>

<p>Next time I’ll dive into the details of the <code>InputLine</code> class.&#160; Hope to see you then.</p>  