---
layout: post
title: Fun with initialisers
date: '2018-06-16T22:38:00.000+10:00'
tags:
- C#
modified_time: '2018-06-16T22:38:44.833+10:00'
---

C# has had object and collection initialisers since C# 3.0, but all the docs and blogs I’ve ever seen only cover the basics. We’ve all seen examples like these:<br /><pre><code>var address = new Address<br />{<br />    Line1 = "1 Microsoft Way",<br />    City = "Redmond",<br />    State = "WA",<br />    Zip = 98075<br />};<br /><br />var languages = new List&lt;string&gt;<br />{<br />    "C#",<br />    "Java", <br />    "Python"<br />};<br /></code></pre>But have you ever stopped to think what’s going on under the hood and considered the implications? I want to go there, but first let’s look at dictionaries.<br /><h3>Dictionary Initialisation</h3>We’ve always been able to initialise a dictionary with a collection initialiser like this:<br /><pre><code>var months = new Dictionary&lt;int, string&gt;<br />{<br />    { 1, "January" },<br />    { 2, "February" },<br />    { 3, "March" },<br />    // and the rest, you get the idea<br />};</code></pre>In C# 6.0 a new syntax was introduced, and in pretty much everything I’ve ever read about it it’s described as just that, a new way of writing the dictionary initialisations we’d all come to know and love, a different twist on Collection Initialisers. But the change in dictionary initialisation was actually a side-effect of adding indexer support to Object Initialisers. More on that later.<br /><h3>Collection Initialisers</h3>Collection Initialisers work on any type that implements IEnumerable and has an <code>Add(...)</code> method (or, since C# 6.0, extension method). Look at the list of languages initialisation above. The compiler converts this to the equivalent of:<br /><pre><code>var _c = new List&lt;string&gt;();<br />_c.Add("C#");<br />_c.Add("Java");<br />_c.Add("Python");<br />var languages = _c;</code></pre>The months dictionary initialisation works because of a similar transformation:<br /><pre><code>var _d = new Dictionary&lt;int, string&gt;();<br />_d.Add(1, "January");<br />_d.Add(2, "February");<br />// and the rest<br />var months = _d;</code></pre>Note that this is basically then same as the list initialisation. The only difference is the number of parameters taken by the Add method. If you’re anything like me, your next thought is, “can this go beyond 2 parameters?” <br />Before I get to the answer, lets have another look at the requirements for collection initialisers. The two examples above use collection types that are included in the BCL, but that’s not a requirement. The only requirement is that the type implements IEnumerable, and that a suitable Add method is available. So, my next thought after the number of parameters was whether or not collection initialiser can handle multiple Add methods. The answer is pretty cool, but I’m not sure it’s useful for much in real world code.<br />It turns out that when the compiler is transforming the initialiser it looks for an appropriate Add method for each element of the initialiser. This means that you can actually have elements with differing numbers of items in one initialiser, as long as the Add methods are there to support them. Have a look at the following class:<br /><pre><code>class Foo1 : IEnumerable<br />{<br />    public void Add(long a) =&gt; Console.WriteLine("Add with one parameter");<br />    public void Add(string s1, string s2) =&gt; Console.WriteLine("Add with 2 strings");<br />    public void Add(bool f, double d) =&gt; Console.WriteLine("Add with 2 different params");<br />    public void Add(int x, char y, string z) =&gt; Console.WriteLine("Add with 3 parameters");<br /><br /><br />    // We need this to implement IEnumerable, but not for this example<br />    public IEnumerator GetEnumerator() =&gt; throw new NotImplementedException();<br />}</code></pre>Note, that there’s nothing vaguely collection-like about this type, but it is a valid target for a collection initialiser. Here’s an example, and the output it produces:<br /><pre><code>new Foo1<br />{<br />    { "foo", "bar"},<br />    { 42 },<br />    { 3, '9', "27" },<br />    { true, 1.0 }<br />};</code></pre>Output:<br /><pre>Add with 2 strings<br />Add with one parameter<br />Add with 3 parameters<br />Add with 2 different params</pre>So now that we’ve abused collection initialisers, lets turn our attention elsewhere.<br /><h3>Object Initialisers</h3>Before C# 6.0, object initialisers worked by setting fields or properties of the type being initialised. The compiler translates the Address initialisation at the top of this post into the equivalent of the following:<br /><pre><code>var _a  new Address();<br />_a.Line1 = "1 Microsoft Way";<br />_a.City = "Redmond";<br />_a.State = "WA";<br />_a.Zip = 98075;<br />var address = _a;</code></pre>With C# 6.0 came support for setting indexers as well, and this is where the new dictionary initialisation syntax comes from. But initialising dictionaries is not the only place it can be used. Any type with indexers can use this style of initialisation, and it can be mixed with setting properties and fields. Consider this type:<br /><pre><code>class Foo2<br />{<br />    public string bar;<br />    public double Baz { set =&gt; Console.WriteLine("Property setter"); }<br />    public char this[int i] { set =&gt; Console.WriteLine("Indexer with 1 index"); }<br />    public string this[char c, int i] { set =&gt; Console.WriteLine("Indexer with 2 indices"); }<br />}</code></pre>Here we have a field, a property, and two indexers with different number and types of indices. The following initialiser:<br /> <pre><code>new Foo2<br />{<br />    bar = "bar1",<br />    [3] = '9',<br />    Baz = Math.PI,<br />    ['C', 4] = "Middle C"<br />};</code></pre>produces this output:<br /><pre>Indexer with 1 index<br />Property setter<br />Indexer with 2 indices</pre>Again, not sure how useful this is in real life or maintainable code, but it’s interesting nonetheless.<br /><h3>And back to Dictionaries</h3>I’m going to wrap this post up with an interesting difference in behaviour when initialising dictionaries with the two different syntaxes available. Consider the following two initialisations:<br /><pre><code>var d1 = new Dictionary&lt;int, string&gt;<br />{<br />    { 1, "one" },<br />    { 1, "uno" }<br />};<br /><br />var d2 = new Dictionary&lt;int, string&gt;<br />{<br />    [1] = "one",<br />    [1] = "uno"<br />}</code></pre>On the face of it they look equivalent, but the behaviour is very different. The first attempts to call the <code>Dictionary.Add</code> method twice with the same key, resulting in an exception being thrown on the second call. The second initialiser just sets the dictionary indexer twice, resulting in a single entry with a key of <code>1</code> and a value of <code>"uno"</code>.<br />I hope you've enjoyed my exploration (and abuse) of initialisers in C#. Till next time, “Happy Coding”.<br /><br />