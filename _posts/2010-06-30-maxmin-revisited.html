---
layout: post
title: Max/Min revisited
date: '2010-06-30T22:50:00.001+10:00'
tags:
- C# Specifics
- C# Exercise
- ".NET Specifics"
modified_time: '2010-06-30T22:50:14.399+10:00'
---

<p>A kind commenter on <a href="http://learningcsharpnet.blogspot.com/2010/06/exercise-2-fibonacci-and-other-things.html" target="_blank">my last post</a> (thanks Matt) told me about an alternative to my Max/Min implementation.&#160; The .NET framework includes a class library called LINQ (Language INtegrated Query).&#160; In looking through the MSDN library I had seen this mentioned, but figured it had something to do with database queries.&#160; I was partly right, but it turns out that LINQ is far more, and allows an alternate solution to <a href="http://www.jobsnake.com/seek/articles/index.cgi?openarticle&amp;8533" target="_blank">Prashant's second exercise</a>.</p> <a name='more'></a>  <p>The <code>System.Linq</code> namespace includes classes with methods to query any object that implements the IEnumerable interface.&#160; This means that an Array can be queried, just as a database table can be.&#160; I’ll discuss this a bit more in a minute, but right now here is the solution from last post rewritten to use LINQ.</p>  <div class="csharpcode">   <pre><span class="lnum">   1:  </span><span class="kwrd">using</span> System;</pre>

  <pre><span class="lnum">   2:  </span><span class="kwrd">using</span> System.Linq;</pre>

  <pre><span class="lnum">   3:  </span>&#160;</pre>

  <pre><span class="lnum">   4:  </span><span class="kwrd">class</span> MainClass</pre>

  <pre><span class="lnum">   5:  </span>{</pre>

  <pre><span class="lnum">   6:  </span>    <span class="kwrd">static</span> <span class="kwrd">ulong</span> Fibonacci1(<span class="kwrd">uint</span> n)</pre>

  <pre><span class="lnum">   7:  </span>    {</pre>

  <pre><span class="lnum">   8:  </span>        <span class="kwrd">switch</span> (n)</pre>

  <pre><span class="lnum">   9:  </span>        {</pre>

  <pre><span class="lnum">  10:  </span>            <span class="kwrd">case</span> 0:</pre>

  <pre><span class="lnum">  11:  </span>                <span class="kwrd">return</span> 0;</pre>

  <pre><span class="lnum">  12:  </span>            <span class="kwrd">case</span> 1:</pre>

  <pre><span class="lnum">  13:  </span>                <span class="kwrd">return</span> 1;</pre>

  <pre><span class="lnum">  14:  </span>            <span class="kwrd">default</span>:</pre>

  <pre><span class="lnum">  15:  </span>                <span class="kwrd">ulong</span> fN = 1, fNMinusTwo, fNMinusOne = 0;</pre>

  <pre><span class="lnum">  16:  </span>                <span class="kwrd">while</span> (n &gt; 1)</pre>

  <pre><span class="lnum">  17:  </span>                {</pre>

  <pre><span class="lnum">  18:  </span>                    fNMinusTwo = fNMinusOne;</pre>

  <pre><span class="lnum">  19:  </span>                    fNMinusOne = fN;</pre>

  <pre><span class="lnum">  20:  </span>                    fN = fNMinusTwo + fNMinusOne;</pre>

  <pre><span class="lnum">  21:  </span>                    n--;</pre>

  <pre><span class="lnum">  22:  </span>                }</pre>

  <pre><span class="lnum">  23:  </span>                <span class="kwrd">return</span> fN;</pre>

  <pre><span class="lnum">  24:  </span>        }</pre>

  <pre><span class="lnum">  25:  </span>    }</pre>

  <pre><span class="lnum">  26:  </span>    </pre>

  <pre><span class="lnum">  27:  </span>    <span class="kwrd">static</span> <span class="kwrd">ulong</span> Fibonacci2(<span class="kwrd">uint</span> n, <span class="kwrd">ulong</span> nMinusOne = 1, <span class="kwrd">ulong</span> nMinusTwo = 0)</pre>

  <pre><span class="lnum">  28:  </span>    {</pre>

  <pre><span class="lnum">  29:  </span>        <span class="kwrd">switch</span> (n)</pre>

  <pre><span class="lnum">  30:  </span>        {</pre>

  <pre><span class="lnum">  31:  </span>            <span class="kwrd">case</span> 0:</pre>

  <pre><span class="lnum">  32:  </span>                <span class="kwrd">return</span> nMinusTwo;</pre>

  <pre><span class="lnum">  33:  </span>            <span class="kwrd">case</span> 1:</pre>

  <pre><span class="lnum">  34:  </span>                <span class="kwrd">return</span> nMinusOne;</pre>

  <pre><span class="lnum">  35:  </span>            <span class="kwrd">default</span>:</pre>

  <pre><span class="lnum">  36:  </span>                <span class="kwrd">return</span> Fibonacci2(n - 1, nMinusOne + nMinusTwo, nMinusOne);</pre>

  <pre><span class="lnum">  37:  </span>        }</pre>

  <pre><span class="lnum">  38:  </span>    }</pre>

  <pre><span class="lnum">  39:  </span>&#160;</pre>

  <pre><span class="lnum">  40:  </span>    <span class="kwrd">static</span> <span class="kwrd">void</span> Swap&lt;T&gt;(<span class="kwrd">ref</span> T var1, <span class="kwrd">ref</span> T var2) {</pre>

  <pre><span class="lnum">  41:  </span>        T tempVar = var1;</pre>

  <pre><span class="lnum">  42:  </span>        var1 = var2;</pre>

  <pre><span class="lnum">  43:  </span>        var2 = tempVar;</pre>

  <pre><span class="lnum">  44:  </span>    }</pre>

  <pre><span class="lnum">  45:  </span>    </pre>

  <pre><span class="lnum">  46:  </span>    <span class="kwrd">static</span> <span class="kwrd">void</span> Main()</pre>

  <pre><span class="lnum">  47:  </span>    {</pre>

  <pre><span class="lnum">  48:  </span>        Console.WriteLine(<span class="str">&quot;Fibonacci series&quot;</span>);</pre>

  <pre><span class="lnum">  49:  </span>        <span class="kwrd">for</span> (<span class="kwrd">uint</span> index = 0; index &lt;= 10; index++)</pre>

  <pre><span class="lnum">  50:  </span>        {</pre>

  <pre><span class="lnum">  51:  </span>            Console.WriteLine(<span class="str">&quot;F(&quot;</span> + index.ToString() + <span class="str">&quot;)\t&quot;</span> + Fibonacci1(index).ToString() + <span class="str">&quot;\t&quot;</span> + Fibonacci2(index).ToString());</pre>

  <pre><span class="lnum">  52:  </span>        }</pre>

  <pre><span class="lnum">  53:  </span>&#160;</pre>

  <pre><span class="lnum">  54:  </span>        Console.WriteLine (<span class="str">&quot;\nSwapping int Variables&quot;</span>);</pre>

  <pre><span class="lnum">  55:  </span>        <span class="kwrd">int</span> a = 5;</pre>

  <pre><span class="lnum">  56:  </span>        <span class="kwrd">int</span> b = 10;</pre>

  <pre><span class="lnum">  57:  </span>        Console.WriteLine(<span class="str">&quot;Before:\tA=&quot;</span> + a.ToString() + <span class="str">&quot;\tB=&quot;</span> + b.ToString());</pre>

  <pre><span class="lnum">  58:  </span>        Swap(<span class="kwrd">ref</span> a, <span class="kwrd">ref</span> b);</pre>

  <pre><span class="lnum">  59:  </span>        Console.WriteLine(<span class="str">&quot;Before:\tA=&quot;</span> + a.ToString() + <span class="str">&quot;\tB=&quot;</span> + b.ToString());</pre>

  <pre><span class="lnum">  60:  </span>        </pre>

  <pre><span class="lnum">  61:  </span>        Console.WriteLine(<span class="str">&quot;\nSwapping char Variables&quot;</span>);</pre>

  <pre><span class="lnum">  62:  </span>        <span class="kwrd">char</span> c = <span class="str">'C'</span>;</pre>

  <pre><span class="lnum">  63:  </span>        <span class="kwrd">char</span> d = <span class="str">'D'</span>;</pre>

  <pre><span class="lnum">  64:  </span>        Console.WriteLine(<span class="str">&quot;Before:\tC=&quot;</span> + c.ToString() + <span class="str">&quot;\tD=&quot;</span> + d.ToString());</pre>

  <pre><span class="lnum">  65:  </span>        Swap(<span class="kwrd">ref</span> c, <span class="kwrd">ref</span> d);</pre>

  <pre><span class="lnum">  66:  </span>        Console.WriteLine(<span class="str">&quot;Before:\tC=&quot;</span> + c.ToString() + <span class="str">&quot;\tD=&quot;</span> + d.ToString());</pre>

  <pre><span class="lnum">  67:  </span>&#160;</pre>

  <pre><span class="lnum">  68:  </span>        <span class="kwrd">int</span>[] integerArray =  { 15, 4, 76, 53, 25, 63 };</pre>

  <pre><span class="lnum">  69:  </span>        Console.Write(<span class="str">&quot;\nArray = {&quot;</span>);</pre>

  <pre><span class="lnum">  70:  </span>        <span class="kwrd">for</span> (<span class="kwrd">uint</span> index = 0; index &lt; integerArray.Count(); Console.Write(<span class="str">&quot; &quot;</span> + integerArray[index++].ToString() + <span class="str">&quot;,&quot;</span>));</pre>

  <pre><span class="lnum">  71:  </span>        Console.WriteLine(<span class="str">&quot;\b }&quot;</span>);</pre>

  <pre><span class="lnum">  72:  </span>        Console.WriteLine(<span class="str">&quot;Maximum = &quot;</span> + integerArray.Max().ToString());</pre>

  <pre><span class="lnum">  73:  </span>        Console.WriteLine(<span class="str">&quot;Minimum = &quot;</span> + integerArray.Min().ToString());</pre>

  <pre><span class="lnum">  74:  </span>    }</pre>

  <pre><span class="lnum">  75:  </span>}</pre>
</div>

<p>Notice that the Min and Max methods are gone.&#160; Instead, the array is queried directly, using what appears to be a method of the Array.&#160; In actual fact <code>Max()</code> and <code>Min()</code> are <strong>extension methods</strong> provided by the System.Linq.Enumerable class.&#160;&#160; The <code>using System.Linq;</code> statement in line 2 brings these extension methods, and many others, into scope so they can be used directly from the array object.</p>

<p>Matt also pointed me to Microsoft’s <a href="http://msdn.microsoft.com/en-us/library/ms229043.aspx">Capitalization Conventions</a> for use in developing class libraries.&#160; I’ve renamed some of the variables and parameters in this solution to adhere to these conventions.</p>

<h4>More on Extension Methods</h4>

<p>To quote the <a href="http://msdn.microsoft.com/en-us/library/67ef8sbd.aspx">C# Programming Guide</a> in MSDN:</p>

<blockquote>
  <p>Extension methods enable you to &quot;add&quot; methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type. Extension methods are a special kind of static method, but they are called as if they were instance methods on the extended type. For client code written in C# and Visual Basic, there is no apparent difference between calling an extension method and the methods that are actually defined in a type.</p>
</blockquote>

<p>An extension method is basically a static method, but the first parameter identifies the type that the method extends, and is preceded by the <code>this</code> keyword.&#160; So the <code>Max()</code> method used above is defined as follows:</p>

<pre class="csharpcode"><span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">int</span> Max(
    <span class="kwrd">this</span> IEnumerable&lt;<span class="kwrd">int</span>&gt; source
)</pre>

<p>This means that this method is usable on any type that implements IEnumerable&lt;int&gt;, and there are versions of this extension method for each of the other numeric types, as well as a generic one in which you can specify a comparison method.</p>

<p>I’ll leave that here for now.&#160; Next time I’ll address Prashant’s third exercise.</p>  